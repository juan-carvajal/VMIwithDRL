# Import PuLP modeler functions
from collections import namedtuple
import docplex.mp
from docplex.mp.model import Model
from docplex.util.environment import get_environment


# from __future__ import print_function

# import cplex


class AllocationOptimizer():
    def __init__(self, II, A, D, CV, CF, R, H):
        self.II = II
        self.A = A
        self.D = D
        self.CV = CV
        self.CF = CF
        self.M = 1000000
        self.R = list(range(R))
        self.H = list(range(H))

    @property
    def allocate(self, **kwargs):
        # self.R = list(range(5))
        RX = list(range(len(self.R)))
        mdl = Model(name='LPOptimizationProblem', **kwargs)

        x = mdl.integer_var_matrix(self.H, RX, 0, None, "x")
        I0 = mdl.integer_var_dict(self.H, 0, None, "I0")
        F = mdl.integer_var_dict(self.H, 0, None, "Fh")
        YI0 = mdl.binary_var_dict(self.H)
        YF = mdl.binary_var_dict(self.H)
       
        mdl.minimize(mdl.sum(I0[h] * self.CV + F[h] * self.CF for h in self.H))

  
    
        mdl.add_constraints([self.D[h] - x[h,0] - self.II[h][1] <= self.M * YI0[h] for h in self.H])
       
        mdl.add_constraints(self.II[h][1] + x[h,0] - self.D[h] <= self.M * (1 - YI0[h]) for h in self.H)

        mdl.add_constraints(I0[h] >= 0 for h in self.H)

        mdl.add_constraints(I0[h] - self.II[h][1] + x[h,0] - self.D[h] >= 0 for h in self.H)

        mdl.add_constraints( I0[h] <= self.M * (1 - YI0[h]) for h in self.H )
        
        mdl.add_constraints(I0[h] <= self.II[h][1] + x[h,0] - self.D[h] + self.M * YI0[h] for h in self.H)
          
        ########################################

       
        mdl.add_constraints(
            -self.D[h] + mdl.sum([self.II[h][r] for (r) in self.R]) + mdl.sum([x[h,r] for (r) in self.R]) <= self.M *
            YF[h] for h in self.H)

        mdl.add_constraints(
            self.D[h] - mdl.sum([self.II[h][r] for (r) in self.R]) - mdl.sum([x[h,r] for (r) in self.R]) <= self.M * (
                    1 - YF[h]) for h in self.H)

        mdl.add_constraints(F[h] >= 0 for h in self.H)

        mdl.add_constraints(
            F[h] >= self.D[h] - mdl.sum([self.II[h][r] for (r) in self.R]) - mdl.sum([x[h,r] for (r) in self.R]) for h
            in self.H)

        mdl.add_constraints(F[h] <= self.M * (1 - YF[h]) for h in self.H)

        mdl.add_constraints(F[h] <= self.D[h] - mdl.sum([self.II[h][r] for (r) in self.R]) - mdl.sum(
            [x[h,r] for (r) in self.R]) + self.M * YF[h] for h in self.H)
        
        mdl.add_constraints(F[h] <= 0.25 * mdl.sum([F[h1] for (h1) in self.H]) for h in self.H)

        for r in self.R:
            mdl.add_constraint(self.A[r] >= mdl.sum([x[h,r] for (h) in self.H]))

        mdl.add_constraint((mdl.sum([self.II[0][r] for (r) in self.R]) + mdl.sum([x[0,r] for (r) in self.R])) / self.D[
            0] == (
                mdl.sum([self.II[1][r] for (r) in self.R]) + mdl.sum([x[1,r] for (r) in self.R])) / self.D[1])
        mdl.add_constraint((mdl.sum([self.II[1][r] for (r) in self.R]) + mdl.sum([x[1,r] for (r) in self.R])) / self.D[
            1] == (
                mdl.sum([self.II[2][r] for (r) in self.R]) + mdl.sum([x[2,r] for (r) in self.R])) / self.D[2])
        mdl.add_constraint((mdl.sum([self.II[2][r] for (r) in self.R]) + mdl.sum([x[2,r] for (r) in self.R])) / self.D[
            2] <= (
                mdl.sum([self.II[3][r] for (r) in self.R]) + mdl.sum([x[3,r] for (r) in self.R])) / self.D[3])

   
        mdl.solve()

        # The status of the solution is printed to the screen
        # print("Status:", LpStatus[prob.status])

        # for r in self.R:
        #     for h in self.H:
        #         print ("x" + str(h) + str(r), x[h][r].varValue)

        # The optimised objective function value is printed to the screen
        # print ("costo total = ", value(prob.objective))
        # print(type(x[0][0]))

        return x
# Create the 'prob' variable to contain the problem data
# R = list(range(5))
# H = list(range(4))
# RX = list(range(5))
#
# II = [[0, 0, 0, 0],
#       [2, 1, 1, 3],
#       [0, 0, 2, 5],
#       [3, 3, 2, 1],
#       [0, 3, 5, 1]]
#
#
# D = [5,10,15,20]
#
# A = [6,7,8,9,10]
#
# M=1000000;
#
# CF = 100
# CV = 10

# a = AllocationOptimizer(II,A,D,CV,CF,R,H)
# print(a.allocate())
